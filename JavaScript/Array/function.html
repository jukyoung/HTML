<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열 함수</title>
</head>
<body>
    <p>다음 중 좋아하는 과일의 이름을 적으시오.
        <p>딸기 / 멜론 / 사과 / 오렌지</p>
        <input type="text" id="userInput" placeholder="과일입력">
        <button type="button" id="complete">완료</button>
    </p>

    <script>
        /*
        let userInput = document.getElementById("userInput");
        let complete = document.getElementById("complete");

        // 배열 생성 -> 특정 값이 그 배열의 몇번 인덱스에 있는지 확인

          indexOf(값) : 값을 인자값으로 넘겨서 해당 배열의 가장 첫번째 값을 찾아 그 인덱스 반환
          -> 만약에 인자로 넘겨준 값이 존재하지 않는다면 -1을 반환

       
    //    let tempArr = ['a', 'b', 'c', 'a'];
    //    let index = tempArr.indexOf("c");
    //    console.log(index); // 몇번 인덱스에 해당 값이 있는지 알려줌
        let inputArr = ["딸기", "멜론", "사과", "오렌지"];

        complete.onclick = function(){
            let input = userInput.value;
            let index = inputArr.indexOf(input);
            if(index == -1){
                alert("입력한 값이 존재하지 않습니다.")
            }else{        
                alert("입력한 "+input+"은/는 배열의 "+index+"번 인덱스에 있습니다.");
            };
        }*/

        /*
           concat(값/배열) : 값이나 배열을 결합해서 새로운 배열을 반환해주는 함수
           -> 원본 배열에 영항을 주지 않음
        */
       /*
        let arr1 = ["바나나", "딸기", "수박"];
        let arr2 = ["사과", "귤"];
        let arr3 = [10, 20, 30];

        let data1 = arr1.concat(arr2);
        console.log("data1 : " , data1);
        let data2 = arr1.concat("망고");
        console.log("data2 : " , data2);

        let data3 = arr1.concat(arr2, arr3);
        console.log("data3 : " ,data3);

        console.log(arr1);
        */

        /* 
          join(구분자) : 배열을 결합해 문자열로 반환
          -> 하나의 배열안의 요소들을 모두 합쳐서 문자열로 반환
          -> 인자값이 없을 경우 ,를 기준으로 요소들을 결합
          -> 인자값으로 구분자를 넘겨주면 해당 구분자를 기준으로 요소들을 결합
          -> 원본배열은 영향받지 않음
        */
       /*
        let arr1 = ["바나나", "딸기", "수박"];
        let arr2 = ["사과", "귤"];
        let arr3 = [10, 20, 30];

        let data1 = arr1.concat(arr2, arr3);
        console.log("data1 : " , data1);

        let data2 = data1.join();
        console.log("data2 : " , data2);

        let data3 = data1.join("+");
        console.log("data3 : " ,data3);
        */
       /* 
         reverse() : 배열의 순서를 뒤집어주는 함수
         -> 실제 원본 배열의 데이터 순서가 바뀜
       */
      /*
       let arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
       let arr2 = ["홍길동", "임꺽정", "세종대왕", "이순신"];

       arr1.reverse();
       console.log("arr1 : " , arr1);
       arr2.reverse();
       console.log("arr2 : " , arr2);
       */
      /* 
        sort() : 배열안의 데이터를 오름차순 정렬 / 내림차순 정렬해주는 함수
                -> 인자값 없이 사용했을 때는 문자열 기준으로 오름차순

     
        let arr1 = ['마', '가', '라', '아', '하', '나'];
        let arr2 = [5, 1, 3, 10, 9, 6, 8, 2, 4, 7]; 
        */
        /*
        arr1.sort();
        console.log("arr1 : " , arr1);

        arr2.sort(); // 숫자의 경우 문자열로 변환되어 정렬이 이루어지기 때문에
        // 숫자로써의 올바른 정렬이 이뤄지지 않음
        console.log("arr2 : " , arr2);
        */
       /* 
         sort() 함수의 인자값으로 compareFunction(비교함수)을 넘겨줘 
         오름차순, 내림차순을 정확히 해줄 수 있음
         -> 원본 데이터 영향 받음

         sort(sortASC);
         sort(sortDESC);
         함수 그 자체를 넘겨줌

         compareFunction(a, b) 
         : 0보다 작은 수 반환(음수) -> a를 b 보다 낮은 인덱스로 정렬 - 오름차순
         compareFunction(a, b) 
         : 0을 반환 -> a와 b의 인덱스를 변경하지 않음
         compareFunction(a, b) 
         : 0보다 큰 수 반환(양수) -> b를 a 보다 낮은 인덱스로 정렬 - 내림차순
       */
      /*
       function sortASC(a,b){
            return a-b;
       }
       function sortDESC(a,b){
            return b-a;
       }
       
       arr2.sort(sortASC);
       console.log("arr2 : " ,arr2);

       arr2.sort(sortDESC);
       console.log("arr2 : " , arr2);

       function sortStrDESC(a,b){ //내림차순
           if(a < b){
               return 1;
           }else if(a > b){
               return -1;
           }else{
               return 0;
           }
       }

       arr1.sort(sortStrDESC);
       console.log("arr1 : " ,arr1);
       */

       /*
          push(값) : 배열의 가장 끝 인덱스에 새로운 값 추가 
          pop() : 배열의 가장 끝 인덱스에 있는 값 삭제
          원본 데이터에 영향 줌
       */
      /*
      let fruit = ["apple" , "banana", "mango"];
      fruit.push("strawberry");
      console.log("fruit : " , fruit);
      fruit.pop();
      console.log("fruit : " ,fruit);
      */

      /*
        unshift() : 배열의 첫 인덱스에 새로운 값 추가
        -> 원래 인덱스의 데이터들은 뒤로 1씩 밀려남
        shift(값): 배열의 첫 인덱스 값 삭제
        -> 원래 데이터의 인덱스가 앞으로 1씩 당겨짐
      */
     /*
      let fruit = ["apple" , "banana", "mango"];
      fruit.unshift("watermelon");
      console.log("fruit : " , fruit);
      fruit.shift();
      console.log("fruit : " , fruit);
      */

      /*
        slice(인자1, 인자2) : 배열의 데이터를 잘라내는 함수 (배열에서 값이 잘려진 상태로 반환)
        인자 1 -> 해당 인덱스 전까지 잘라내겠다
        인자 1 = 시작 인덱스
        시작 인덱스에서부터 데이터를 잘라서 자른 데이터를 배열로 만들어 반환

        인자 2 = 끝 인덱스
        시작 인덱스에서부터 데이터를 끝 인덱스 전까지 잘라서 배열로 반환
        -> 끝 인덱스(인자2)가 없으면 배열의 끝인덱스까지 모두 잘라버림

        원본 배열 영향 X
      */
     /*
     let data = ['apple', 'banana', 'mango', 'watermelon', 'grape'];
     
     console.log(data.slice(1)); // 1번 인덱스 전까지 잘라내겠다 -> 0번 인덱스를 잘라냄

     console.log(data.slice(1, 3));
     */
    /* 
       splice(index, 제거수, [추가값]) 
       : 시작 인덱스를 기준으로 해서 원하는 개수만큼 데이터를 제거할 수 있음
       + 세번째 인자인 새로운 값을 추가하는 것도 가능함 함수 
       -> 원본 배열에 영향을 줌

       시작 index : 해당 인덱스부터 값을 제거해라 
       (만약 index 값만 인자로 넘겨주면 해당 인덱스 부터 나머지 인덱스 데이터 모두 삭제)

       제거수 : 몇 개의 요소를 삭제할건지
       추가값 : 삭제한 요소의 자리에 새롭게 넣어줄 값

    */
    let data = ['apple', 'banana', 'mango', 'watermelon', 'grape'];
    //data.splice(1);
    //data.splice(1, 2);
    //data.splice(1, 1, "strawberry");
    //data.splice(1, 2, "strawberry");// 여러개의 요소가 삭제되도 새로운 값은 1번만 들어가게 됨.
    //data.splice(1, 0, "strawberry"); // 삭제하지 않고 특정한 값만 추가시키고자 할때
    data.splice(-1, 1); // 음수 인덱스는 뒤에서부터 시작
    console.log(data); 


    </script>
</body>
</html>